"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceImporter = void 0;
exports.removeNonImportResources = removeNonImportResources;
const util_1 = require("util");
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const fs = require("fs-extra");
const promptly = require("promptly");
const deployments_1 = require("../deployments");
const private_1 = require("../io/private");
const toolkit_error_1 = require("../toolkit-error");
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
class ResourceImporter {
    _currentTemplate;
    stack;
    cfn;
    ioHelper;
    constructor(stack, props) {
        this.stack = stack;
        this.cfn = props.deployments;
        this.ioHelper = props.ioHelper;
    }
    /**
     * Ask the user for resources to import
     */
    async askForResourceIdentifiers(available) {
        const ret = { importResources: [], resourceMap: {} };
        const resourceIdentifiers = await this.resourceIdentifiers();
        for (const resource of available) {
            const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
            if (!identifier) {
                continue;
            }
            ret.importResources.push(resource);
            ret.resourceMap[resource.logicalId] = identifier;
        }
        return ret;
    }
    /**
     * Load the resources to import from a file
     */
    async loadResourceIdentifiers(available, filename) {
        const contents = await fs.readJson(filename);
        const ret = { importResources: [], resourceMap: {} };
        for (const resource of available) {
            const descr = this.describeResource(resource.logicalId);
            const idProps = contents[resource.logicalId];
            if (idProps) {
                await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg((0, util_1.format)('%s: importing using %s', chalk.blue(descr), chalk.blue(fmtdict(idProps)))));
                ret.importResources.push(resource);
                ret.resourceMap[resource.logicalId] = idProps;
                delete contents[resource.logicalId];
            }
            else {
                await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg((0, util_1.format)('%s: skipping', chalk.blue(descr))));
            }
        }
        const unknown = Object.keys(contents);
        if (unknown.length > 0) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_WARN.msg(`Unrecognized resource identifiers in mapping file: ${unknown.join(', ')}`));
        }
        return ret;
    }
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param importMap Mapping from CDK construct tree path to physical resource import identifiers
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMap(importMap, options = {}) {
        const resourcesToImport = await this.makeResourcesToImport(importMap);
        const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    /**
     * Based on the app and resources file generated by cdk migrate. Removes all items from the template that
     * cannot be included in an import change-set for new stacks and performs the import operation,
     * creating the new stack.
     *
     * @param resourcesToImport The mapping created by cdk migrate
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMigrate(resourcesToImport, options = {}) {
        const updatedTemplate = this.removeNonImportResources();
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    async importResources(overrideTemplate, resourcesToImport, options) {
        try {
            const result = await this.cfn.deployStack({
                stack: this.stack,
                deployName: this.stack.stackName,
                ...options,
                overrideTemplate,
                resourcesToImport,
            });
            (0, deployments_1.assertIsSuccessfulDeployStackResult)(result);
            const message = result.noOp
                ? ' ✅  %s (no changes)'
                : ' ✅  %s';
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg('\n' + chalk.green((0, util_1.format)(message, this.stack.displayName))));
        }
        catch (e) {
            await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_E3900.msg((0, util_1.format)('\n ❌  %s failed: %s', chalk.bold(this.stack.displayName), e), { error: e }));
            throw e;
        }
    }
    /**
     * Perform a diff between the currently running and the new template, ensure that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    async discoverImportableResources(allowNonAdditions = false) {
        const currentTemplate = await this.currentTemplate();
        const diff = cfnDiff.fullDiff(currentTemplate, this.stack.template);
        // Ignore changes to CDKMetadata
        const resourceChanges = Object.entries(diff.resources.changes)
            .filter(([logicalId, _]) => logicalId !== 'CDKMetadata');
        // Split the changes into additions and non-additions. Imports only make sense
        // for newly-added resources.
        const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
        const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
        if (nonAdditions.length) {
            const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
            if (allowNonAdditions) {
                await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_WARN.msg(`Ignoring updated/deleted resources (--force): ${offendingResources.join(', ')}`));
            }
            else {
                throw new toolkit_error_1.ToolkitError('No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes ' +
                    `to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(', ')} (--force to override)`);
            }
        }
        // Resources in the new template, that are not present in the current template, are a potential import candidates
        return {
            additions: additions.map(([logicalId, resourceDiff]) => ({
                logicalId,
                resourceDiff,
                resourceDefinition: addDefaultDeletionPolicy(this.stack.template?.Resources?.[logicalId] ?? {}),
            })),
            hasNonAdditions: nonAdditions.length > 0,
        };
    }
    /**
     * Resolves the environment of a stack.
     */
    async resolveEnvironment() {
        return this.cfn.resolveEnvironment(this.stack);
    }
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    async currentTemplate() {
        if (!this._currentTemplate) {
            this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
        }
        return this._currentTemplate;
    }
    /**
     * Return the current template, with the given resources added to it
     */
    async currentTemplateWithAdditions(additions) {
        const template = await this.currentTemplate();
        if (!template.Resources) {
            template.Resources = {};
        }
        for (const add of additions) {
            template.Resources[add.logicalId] = add.resourceDefinition;
        }
        return template;
    }
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    async resourceIdentifiers() {
        const ret = {};
        const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack);
        for (const summary of resourceIdentifierSummaries) {
            if ('ResourceType' in summary && summary.ResourceType && 'ResourceIdentifiers' in summary && summary.ResourceIdentifiers) {
                ret[summary.ResourceType] = (summary.ResourceIdentifiers ?? [])?.map(x => x.split(','));
            }
        }
        return ret;
    }
    /**
     * Ask for the importable identifier for the given resource
     *
     * There may be more than one identifier under which a resource can be imported. The `import`
     * operation needs exactly one of them.
     *
     * - If we can get one from the template, we will use one.
     * - Otherwise, we will ask the user for one of them.
     */
    async askForResourceIdentifier(resourceIdentifiers, chg) {
        const resourceName = this.describeResource(chg.logicalId);
        // Skip resources that do not support importing
        const resourceType = chg.resourceDiff.newResourceType;
        if (resourceType === undefined || !(resourceType in resourceIdentifiers)) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_WARN.msg(`${resourceName}: unsupported resource type ${resourceType}, skipping import.`));
            return undefined;
        }
        const idPropSets = resourceIdentifiers[resourceType];
        // Retain only literal strings: strip potential CFN intrinsics
        const resourceProps = Object.fromEntries(Object.entries(chg.resourceDefinition.Properties ?? {})
            .filter(([_, v]) => typeof v === 'string'));
        // Find property sets that are fully satisfied in the template, ask the user to confirm them
        const satisfiedPropSets = idPropSets.filter(ps => ps.every(p => resourceProps[p]));
        for (const satisfiedPropSet of satisfiedPropSets) {
            const candidateProps = Object.fromEntries(satisfiedPropSet.map(p => [p, resourceProps[p]]));
            const displayCandidateProps = fmtdict(candidateProps);
            if (await promptly.confirm(`${chalk.blue(resourceName)} (${resourceType}): import with ${chalk.yellow(displayCandidateProps)} (yes/no) [default: yes]? `, { default: 'yes' })) {
                return candidateProps;
            }
        }
        // If we got here and the user rejected any available identifiers, then apparently they don't want the resource at all
        if (satisfiedPropSets.length > 0) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(chalk.grey(`Skipping import of ${resourceName}`)));
            return undefined;
        }
        // We cannot auto-import this, ask the user for one of the props
        // The only difference between these cases is what we print: for multiple properties, we print a preamble
        const prefix = `${chalk.blue(resourceName)} (${resourceType})`;
        let preamble;
        let promptPattern;
        if (idPropSets.length > 1) {
            preamble = `${prefix}: enter one of ${idPropSets.map(x => chalk.blue(x.join('+'))).join(', ')} to import (all empty to skip)`;
            promptPattern = `${prefix}: enter %`;
        }
        else {
            promptPattern = `${prefix}: enter %`;
        }
        // Do the input loop here
        if (preamble) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(preamble));
        }
        for (const idProps of idPropSets) {
            const input = {};
            for (const idProp of idProps) {
                // If we have a value from the template, use it as default. This will only be a partial
                // identifier if present, otherwise we would have done the import already above.
                const defaultValue = resourceProps[idProp] ?? '';
                const prompt = [
                    promptPattern.replace(/%/g, chalk.blue(idProp)),
                    defaultValue
                        ? `[${defaultValue}]`
                        : '(empty to skip)',
                ].join(' ') + ':';
                const response = await promptly.prompt(prompt, { default: defaultValue, trim: true });
                if (!response) {
                    break;
                }
                input[idProp] = response;
                // Also stick this property into 'resourceProps', so that it may be reused by a subsequent question
                // (for a different compound identifier that involves the same property). Just a small UX enhancement.
                resourceProps[idProp] = response;
            }
            // If the user gave inputs for all values, we are complete
            if (Object.keys(input).length === idProps.length) {
                return input;
            }
        }
        await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(chalk.grey(`Skipping import of ${resourceName}`)));
        return undefined;
    }
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    async makeResourcesToImport(resourceMap) {
        return resourceMap.importResources.map(res => ({
            LogicalResourceId: res.logicalId,
            ResourceType: res.resourceDiff.newResourceType,
            ResourceIdentifier: resourceMap.resourceMap[res.logicalId],
        }));
    }
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    describeResource(logicalId) {
        return this.stack.template?.Resources?.[logicalId]?.Metadata?.['aws:cdk:path'] ?? logicalId;
    }
    /**
     * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
     * @returns template with import resources only
     */
    removeNonImportResources() {
        return removeNonImportResources(this.stack);
    }
}
exports.ResourceImporter = ResourceImporter;
function fmtdict(xs) {
    return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(', ');
}
/**
 * Add a default `DeletionPolicy` policy.
 * The default value is set to 'Retain', to lower risk of unintentionally
 * deleting stateful resources in the process of importing to CDK.
 */
function addDefaultDeletionPolicy(resource) {
    if (resource.DeletionPolicy) {
        return resource;
    }
    return {
        ...resource,
        DeletionPolicy: 'Retain',
    };
}
function removeNonImportResources(stack) {
    const template = stack.template;
    delete template.Resources.CDKMetadata;
    delete template.Outputs;
    return template;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3Jlc291cmNlLWltcG9ydC9pbXBvcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUE0ZkEsNERBS0M7QUFqZ0JELCtCQUE4QjtBQUM5Qix3REFBd0Q7QUFJeEQsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFFckMsZ0RBQXFFO0FBQ3JFLDJDQUFrRDtBQUVsRCxvREFBZ0Q7QUFrRmhEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQWEsZ0JBQWdCO0lBQ25CLGdCQUFnQixDQUFNO0lBRWIsS0FBSyxDQUFvQztJQUN6QyxHQUFHLENBQWM7SUFDakIsUUFBUSxDQUFXO0lBRXBDLFlBQ0UsS0FBd0MsRUFDeEMsS0FBNEI7UUFFNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQzdCLElBQUksQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMseUJBQXlCLENBQUMsU0FBK0I7UUFDcEUsTUFBTSxHQUFHLEdBQWMsRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUNoRSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFFN0QsS0FBSyxNQUFNLFFBQVEsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUNqQyxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxtQkFBbUIsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUN0RixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ2hCLFNBQVM7WUFDWCxDQUFDO1lBRUQsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFB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SUFBSSxDQUFDLENBQUM7QUFDcEUsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLHdCQUF3QixDQUFDLFFBQWE7SUFDN0MsSUFBSSxRQUFRLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDNUIsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVELE9BQU87UUFDTCxHQUFHLFFBQVE7UUFDWCxjQUFjLEVBQUUsUUFBUTtLQUN6QixDQUFDO0FBQ0osQ0FBQztBQU9ELFNBQWdCLHdCQUF3QixDQUFDLEtBQXVDO0lBQzlFLE1BQU0sUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUM7SUFDaEMsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQztJQUN0QyxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUM7SUFDeEIsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZvcm1hdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY2ZuRGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB0eXBlIHsgUmVzb3VyY2VEaWZmZXJlbmNlIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWRmb3JtYXRpb24tZGlmZic7XG5pbXBvcnQgdHlwZSAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgdHlwZSB7IFJlc291cmNlSWRlbnRpZmllclN1bW1hcnksIFJlc291cmNlVG9JbXBvcnQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHR5cGUgeyBEZXBsb3ltZW50TWV0aG9kLCBEZXBsb3ltZW50cyB9IGZyb20gJy4uL2RlcGxveW1lbnRzJztcbmltcG9ydCB7IGFzc2VydElzU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi4vZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgSU8sIHR5cGUgSW9IZWxwZXIgfSBmcm9tICcuLi9pby9wcml2YXRlJztcbmltcG9ydCB0eXBlIHsgVGFnIH0gZnJvbSAnLi4vdGFncyc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi90b29sa2l0LWVycm9yJztcblxuZXhwb3J0IHR5cGUgUmVzb3VyY2VzVG9JbXBvcnQgPSBSZXNvdXJjZVRvSW1wb3J0W107XG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMgPSBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJ5W107XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VJbXBvcnRlclByb3BzIHtcbiAgZGVwbG95bWVudHM6IERlcGxveW1lbnRzO1xuICBpb0hlbHBlcjogSW9IZWxwZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0RGVwbG95bWVudE9wdGlvbnMge1xuICAvKipcbiAgICogUm9sZSB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGZvciBkZXBsb3ltZW50XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gRGVmYXVsdCBzdGFjayByb2xlXG4gICAqL1xuICByZWFkb25seSByb2xlQXJuPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZXBsb3ltZW50IG1ldGhvZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIENoYW5nZSBzZXQgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAgICovXG4gIHJlYWRvbmx5IGRlcGxveW1lbnRNZXRob2Q/OiBEZXBsb3ltZW50TWV0aG9kO1xuXG4gIC8qKlxuICAgKiBTdGFjayB0YWdzIChwYXNzIHRocm91Z2ggdG8gQ2xvdWRGb3JtYXRpb24pXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gdGFnc1xuICAgKi9cbiAgcmVhZG9ubHkgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBVc2UgcHJldmlvdXMgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIElmIG5vdCBzZXQsIGFsbCBwYXJhbWV0ZXJzIG11c3QgYmUgc3BlY2lmaWVkIGZvciBldmVyeSBkZXBsb3ltZW50LlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSB1c2VQcmV2aW91c1BhcmFtZXRlcnM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSb2xsYmFjayBmYWlsZWQgZGVwbG95bWVudHNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sbGJhY2s/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFNldCBvZiBwYXJhbWV0ZXJzIHRoYXQgdW5pcXVlbHkgaWRlbnRpZnkgYSBwaHlzaWNhbCByZXNvdXJjZSBvZiBhIGdpdmVuIHR5cGVcbiAqIGZvciB0aGUgaW1wb3J0IG9wZXJhdGlvbiwgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIHtcbiAqICAgXCJBV1M6OlMzOjpCdWNrZXRcIjogW1tcIkJ1Y2tldE5hbWVcIl1dLFxuICogICBcIkFXUzo6RHluYW1vREI6Okdsb2JhbFRhYmxlXCI6IFtbXCJUYWJsZU5hbWVcIl0sIFtcIlRhYmxlQXJuXCJdLCBbXCJUYWJsZVN0cmVhbUFyblwiXV0sXG4gKiAgIFwiQVdTOjpSb3V0ZTUzOjpLZXlTaWduaW5nS2V5XCI6IFtbXCJIb3N0ZWRab25lSWRcIiwgXCJOYW1lXCJdXSxcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJzID0geyBbcmVzb3VyY2VUeXBlOiBzdHJpbmddOiBzdHJpbmdbXVtdIH07XG5cbnR5cGUgUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyA9IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbi8qKlxuICogTWFwcGluZyBvZiBDREsgcmVzb3VyY2VzIChMMSBjb25zdHJ1Y3RzKSB0byBwaHlzaWNhbCByZXNvdXJjZXMgdG8gYmUgaW1wb3J0ZWRcbiAqIGluIHRoZWlyIHBsYWNlLCBleGFtcGxlOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIk15U3RhY2svTXlTM0J1Y2tldC9SZXNvdXJjZVwiOiB7XG4gKiAgICAgXCJCdWNrZXROYW1lXCI6IFwibXktbWFudWFsbHktY3JlYXRlZC1zMy1idWNrZXRcIlxuICogICB9LFxuICogICBcIk15U3RhY2svTXlWcGMvUmVzb3VyY2VcIjoge1xuICogICAgIFwiVnBjSWRcIjogXCJ2cGMtMTIzNDU2Nzg5XCJcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbnR5cGUgUmVzb3VyY2VNYXAgPSB7IFtsb2dpY2FsUmVzb3VyY2U6IHN0cmluZ106IFJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXMgfTtcblxuLyoqXG4gKiBSZXNvdXJjZSBpbXBvcnRpbmcgdXRpbGl0eSBjbGFzc1xuICpcbiAqIC0gRGV0ZXJtaW5lcyB0aGUgcmVzb3VyY2VzIGFkZGVkIHRvIGEgdGVtcGxhdGUgKGNvbXBhcmVkIHRvIHRoZSBkZXBsb3llZCB2ZXJzaW9uKVxuICogLSBMb29rIHVwIHRoZSBpZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICogICAtIExvYWQgdGhlbSBmcm9tIGEgZmlsZSwgb3JcbiAqICAgLSBBc2sgdGhlIHVzZXIsIGJhc2VkIG9uIGluZm9ybWF0aW9uIHN1cHBsaWVkIHRvIHVzIGJ5IENsb3VkRm9ybWF0aW9uJ3MgR2V0VGVtcGxhdGVTdW1tYXJ5XG4gKiAtIFRyYW5zbGF0ZSB0aGUgaW5wdXQgdG8gYSBzdHJ1Y3R1cmUgZXhwZWN0ZWQgYnkgQ2xvdWRGb3JtYXRpb24sIHVwZGF0ZSB0aGUgdGVtcGxhdGUgdG8gYWRkIHRoZVxuICogICBpbXBvcnRhYmxlIHJlc291cmNlcywgdGhlbiBydW4gYW4gSU1QT1JUIGNoYW5nZXNldC5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlc291cmNlSW1wb3J0ZXIge1xuICBwcml2YXRlIF9jdXJyZW50VGVtcGxhdGU6IGFueTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIHByaXZhdGUgcmVhZG9ubHkgY2ZuOiBEZXBsb3ltZW50cztcbiAgcHJpdmF0ZSByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgICBwcm9wczogUmVzb3VyY2VJbXBvcnRlclByb3BzLFxuICApIHtcbiAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgdGhpcy5jZm4gPSBwcm9wcy5kZXBsb3ltZW50cztcbiAgICB0aGlzLmlvSGVscGVyID0gcHJvcHMuaW9IZWxwZXI7XG4gIH1cblxuICAvKipcbiAgICogQXNrIHRoZSB1c2VyIGZvciByZXNvdXJjZXMgdG8gaW1wb3J0XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVycyhhdmFpbGFibGU6IEltcG9ydGFibGVSZXNvdXJjZVtdKTogUHJvbWlzZTxJbXBvcnRNYXA+IHtcbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgY29uc3QgcmVzb3VyY2VJZGVudGlmaWVycyA9IGF3YWl0IHRoaXMucmVzb3VyY2VJZGVudGlmaWVycygpO1xuXG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBhd2FpdCB0aGlzLmFza0ZvclJlc291cmNlSWRlbnRpZmllcihyZXNvdXJjZUlkZW50aWZpZXJzLCByZXNvdXJjZSk7XG4gICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldC5pbXBvcnRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICByZXQucmVzb3VyY2VNYXBbcmVzb3VyY2UubG9naWNhbElkXSA9IGlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSByZXNvdXJjZXMgdG8gaW1wb3J0IGZyb20gYSBmaWxlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgbG9hZFJlc291cmNlSWRlbnRpZmllcnMoYXZhaWxhYmxlOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSwgZmlsZW5hbWU6IHN0cmluZyk6IFByb21pc2U8SW1wb3J0TWFwPiB7XG4gICAgY29uc3QgY29udGVudHMgPSBhd2FpdCBmcy5yZWFkSnNvbihmaWxlbmFtZSk7XG5cbiAgICBjb25zdCByZXQ6IEltcG9ydE1hcCA9IHsgaW1wb3J0UmVzb3VyY2VzOiBbXSwgcmVzb3VyY2VNYXA6IHt9IH07XG4gICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiBhdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGRlc2NyID0gdGhpcy5kZXNjcmliZVJlc291cmNlKHJlc291cmNlLmxvZ2ljYWxJZCk7XG4gICAgICBjb25zdCBpZFByb3BzID0gY29udGVudHNbcmVzb3VyY2UubG9naWNhbElkXTtcbiAgICAgIGlmIChpZFByb3BzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9JTkZPLm1zZyhmb3JtYXQoJyVzOiBpbXBvcnRpbmcgdXNpbmcgJXMnLCBjaGFsay5ibHVlKGRlc2NyKSwgY2hhbGsuYmx1ZShmbXRkaWN0KGlkUHJvcHMpKSkpKTtcblxuICAgICAgICByZXQuaW1wb3J0UmVzb3VyY2VzLnB1c2gocmVzb3VyY2UpO1xuICAgICAgICByZXQucmVzb3VyY2VNYXBbcmVzb3VyY2UubG9naWNhbElkXSA9IGlkUHJvcHM7XG4gICAgICAgIGRlbGV0ZSBjb250ZW50c1tyZXNvdXJjZS5sb2dpY2FsSWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGZvcm1hdCgnJXM6IHNraXBwaW5nJywgY2hhbGsuYmx1ZShkZXNjcikpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5rbm93biA9IE9iamVjdC5rZXlzKGNvbnRlbnRzKTtcbiAgICBpZiAodW5rbm93bi5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfV0FSTi5tc2coYFVucmVjb2duaXplZCByZXNvdXJjZSBpZGVudGlmaWVycyBpbiBtYXBwaW5nIGZpbGU6ICR7dW5rbm93bi5qb2luKCcsICcpfWApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIHRoZSBwcm92aWRlZCByZXNvdXJjZSBtYXBwaW5nLCBwcmVwYXJlIENGTiBzdHJ1Y3R1cmVzIGZvciBpbXBvcnQgKHRlbXBsYXRlLFxuICAgKiBSZXNvdXJjZXNUb0ltcG9ydCBzdHJ1Y3R1cmUpIGFuZCBwZXJmb3JtIHRoZSBpbXBvcnQgb3BlcmF0aW9uIChDbG91ZEZvcm1hdGlvbiBkZXBsb3ltZW50KVxuICAgKlxuICAgKiBAcGFyYW0gaW1wb3J0TWFwIE1hcHBpbmcgZnJvbSBDREsgY29uc3RydWN0IHRyZWUgcGF0aCB0byBwaHlzaWNhbCByZXNvdXJjZSBpbXBvcnQgaWRlbnRpZmllcnNcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGRlcGxveSBvcGVyYXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRSZXNvdXJjZXNGcm9tTWFwKGltcG9ydE1hcDogSW1wb3J0TWFwLCBvcHRpb25zOiBJbXBvcnREZXBsb3ltZW50T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgcmVzb3VyY2VzVG9JbXBvcnQ6IFJlc291cmNlc1RvSW1wb3J0ID0gYXdhaXQgdGhpcy5tYWtlUmVzb3VyY2VzVG9JbXBvcnQoaW1wb3J0TWFwKTtcbiAgICBjb25zdCB1cGRhdGVkVGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZVdpdGhBZGRpdGlvbnMoaW1wb3J0TWFwLmltcG9ydFJlc291cmNlcyk7XG5cbiAgICBhd2FpdCB0aGlzLmltcG9ydFJlc291cmNlcyh1cGRhdGVkVGVtcGxhdGUsIHJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNlZCBvbiB0aGUgYXBwIGFuZCByZXNvdXJjZXMgZmlsZSBnZW5lcmF0ZWQgYnkgY2RrIG1pZ3JhdGUuIFJlbW92ZXMgYWxsIGl0ZW1zIGZyb20gdGhlIHRlbXBsYXRlIHRoYXRcbiAgICogY2Fubm90IGJlIGluY2x1ZGVkIGluIGFuIGltcG9ydCBjaGFuZ2Utc2V0IGZvciBuZXcgc3RhY2tzIGFuZCBwZXJmb3JtcyB0aGUgaW1wb3J0IG9wZXJhdGlvbixcbiAgICogY3JlYXRpbmcgdGhlIG5ldyBzdGFjay5cbiAgICpcbiAgICogQHBhcmFtIHJlc291cmNlc1RvSW1wb3J0IFRoZSBtYXBwaW5nIGNyZWF0ZWQgYnkgY2RrIG1pZ3JhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGRlcGxveSBvcGVyYXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBpbXBvcnRSZXNvdXJjZXNGcm9tTWlncmF0ZShyZXNvdXJjZXNUb0ltcG9ydDogUmVzb3VyY2VzVG9JbXBvcnQsIG9wdGlvbnM6IEltcG9ydERlcGxveW1lbnRPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1cGRhdGVkVGVtcGxhdGUgPSB0aGlzLnJlbW92ZU5vbkltcG9ydFJlc291cmNlcygpO1xuXG4gICAgYXdhaXQgdGhpcy5pbXBvcnRSZXNvdXJjZXModXBkYXRlZFRlbXBsYXRlLCByZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGltcG9ydFJlc291cmNlcyhvdmVycmlkZVRlbXBsYXRlOiBhbnksIHJlc291cmNlc1RvSW1wb3J0OiBSZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9uczogSW1wb3J0RGVwbG95bWVudE9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jZm4uZGVwbG95U3RhY2soe1xuICAgICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgICAgZGVwbG95TmFtZTogdGhpcy5zdGFjay5zdGFja05hbWUsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIG92ZXJyaWRlVGVtcGxhdGUsXG4gICAgICAgIHJlc291cmNlc1RvSW1wb3J0LFxuICAgICAgfSk7XG5cbiAgICAgIGFzc2VydElzU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0KHJlc3VsdCk7XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXN1bHQubm9PcFxuICAgICAgICA/ICcg4pyFICAlcyAobm8gY2hhbmdlcyknXG4gICAgICAgIDogJyDinIUgICVzJztcblxuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKCdcXG4nICsgY2hhbGsuZ3JlZW4oZm9ybWF0KG1lc3NhZ2UsIHRoaXMuc3RhY2suZGlzcGxheU5hbWUpKSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkNES19UT09MS0lUX0UzOTAwLm1zZyhmb3JtYXQoJ1xcbiDinYwgICVzIGZhaWxlZDogJXMnLCBjaGFsay5ib2xkKHRoaXMuc3RhY2suZGlzcGxheU5hbWUpLCBlKSwgeyBlcnJvcjogZSBhcyBhbnkgfSkpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIGRpZmYgYmV0d2VlbiB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYW5kIHRoZSBuZXcgdGVtcGxhdGUsIGVuc3VyZSB0aGF0IGl0IGlzIHZhbGlkXG4gICAqIGZvciBpbXBvcnRpbmcgYW5kIHJldHVybiBhIGxpc3Qgb2YgcmVzb3VyY2VzIHRoYXQgYXJlIGJlaW5nIGFkZGVkIGluIHRoZSBuZXcgdmVyc2lvblxuICAgKlxuICAgKiBAcmV0dXJuIG1hcHBpbmcgbG9naWNhbFJlc291cmNlSWQgLT4gcmVzb3VyY2VEaWZmZXJlbmNlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZGlzY292ZXJJbXBvcnRhYmxlUmVzb3VyY2VzKGFsbG93Tm9uQWRkaXRpb25zID0gZmFsc2UpOiBQcm9taXNlPERpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlc1Jlc3VsdD4ge1xuICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY3VycmVudFRlbXBsYXRlKCk7XG5cbiAgICBjb25zdCBkaWZmID0gY2ZuRGlmZi5mdWxsRGlmZihjdXJyZW50VGVtcGxhdGUsIHRoaXMuc3RhY2sudGVtcGxhdGUpO1xuXG4gICAgLy8gSWdub3JlIGNoYW5nZXMgdG8gQ0RLTWV0YWRhdGFcbiAgICBjb25zdCByZXNvdXJjZUNoYW5nZXMgPSBPYmplY3QuZW50cmllcyhkaWZmLnJlc291cmNlcy5jaGFuZ2VzKVxuICAgICAgLmZpbHRlcigoW2xvZ2ljYWxJZCwgX10pID0+IGxvZ2ljYWxJZCAhPT0gJ0NES01ldGFkYXRhJyk7XG5cbiAgICAvLyBTcGxpdCB0aGUgY2hhbmdlcyBpbnRvIGFkZGl0aW9ucyBhbmQgbm9uLWFkZGl0aW9ucy4gSW1wb3J0cyBvbmx5IG1ha2Ugc2Vuc2VcbiAgICAvLyBmb3IgbmV3bHktYWRkZWQgcmVzb3VyY2VzLlxuICAgIGNvbnN0IG5vbkFkZGl0aW9ucyA9IHJlc291cmNlQ2hhbmdlcy5maWx0ZXIoKFtfLCBkaWZdKSA9PiAhZGlmLmlzQWRkaXRpb24pO1xuICAgIGNvbnN0IGFkZGl0aW9ucyA9IHJlc291cmNlQ2hhbmdlcy5maWx0ZXIoKFtfLCBkaWZdKSA9PiBkaWYuaXNBZGRpdGlvbik7XG5cbiAgICBpZiAobm9uQWRkaXRpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb2ZmZW5kaW5nUmVzb3VyY2VzID0gbm9uQWRkaXRpb25zLm1hcCgoW2xvZ0lkLCBfXSkgPT4gdGhpcy5kZXNjcmliZVJlc291cmNlKGxvZ0lkKSk7XG5cbiAgICAgIGlmIChhbGxvd05vbkFkZGl0aW9ucykge1xuICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfV0FSTi5tc2coYElnbm9yaW5nIHVwZGF0ZWQvZGVsZXRlZCByZXNvdXJjZXMgKC0tZm9yY2UpOiAke29mZmVuZGluZ1Jlc291cmNlcy5qb2luKCcsICcpfWApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ05vIHJlc291cmNlIHVwZGF0ZXMgb3IgZGVsZXRlcyBhcmUgYWxsb3dlZCBvbiBpbXBvcnQgb3BlcmF0aW9uLiBNYWtlIHN1cmUgdG8gcmVzb2x2ZSBwZW5kaW5nIGNoYW5nZXMgJyArXG4gICAgICAgICAgYHRvIGV4aXN0aW5nIHJlc291cmNlcywgYmVmb3JlIGF0dGVtcHRpbmcgYW4gaW1wb3J0LiBVcGRhdGVkL2RlbGV0ZWQgcmVzb3VyY2VzOiAke29mZmVuZGluZ1Jlc291cmNlcy5qb2luKCcsICcpfSAoLS1mb3JjZSB0byBvdmVycmlkZSlgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXNvdXJjZXMgaW4gdGhlIG5ldyB0ZW1wbGF0ZSwgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIGN1cnJlbnQgdGVtcGxhdGUsIGFyZSBhIHBvdGVudGlhbCBpbXBvcnQgY2FuZGlkYXRlc1xuICAgIHJldHVybiB7XG4gICAgICBhZGRpdGlvbnM6IGFkZGl0aW9ucy5tYXAoKFtsb2dpY2FsSWQsIHJlc291cmNlRGlmZl0pID0+ICh7XG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgcmVzb3VyY2VEaWZmLFxuICAgICAgICByZXNvdXJjZURlZmluaXRpb246IGFkZERlZmF1bHREZWxldGlvblBvbGljeSh0aGlzLnN0YWNrLnRlbXBsYXRlPy5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdID8/IHt9KSxcbiAgICAgIH0pKSxcbiAgICAgIGhhc05vbkFkZGl0aW9uczogbm9uQWRkaXRpb25zLmxlbmd0aCA+IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgZW52aXJvbm1lbnQgb2YgYSBzdGFjay5cbiAgICovXG4gIHB1YmxpYyBhc3luYyByZXNvbHZlRW52aXJvbm1lbnQoKTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudD4ge1xuICAgIHJldHVybiB0aGlzLmNmbi5yZXNvbHZlRW52aXJvbm1lbnQodGhpcy5zdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnRseSBkZXBsb3llZCB0ZW1wbGF0ZSBvZiB0aGUgZ2l2ZW4gc3RhY2sgKFNJTkdMRVRPTilcbiAgICpcbiAgICogQHJldHVybnMgQ3VycmVudGx5IGRlcGxveWVkIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghdGhpcy5fY3VycmVudFRlbXBsYXRlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGVtcGxhdGUgPSBhd2FpdCB0aGlzLmNmbi5yZWFkQ3VycmVudFRlbXBsYXRlKHRoaXMuc3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCB0ZW1wbGF0ZSwgd2l0aCB0aGUgZ2l2ZW4gcmVzb3VyY2VzIGFkZGVkIHRvIGl0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGN1cnJlbnRUZW1wbGF0ZVdpdGhBZGRpdGlvbnMoYWRkaXRpb25zOiBJbXBvcnRhYmxlUmVzb3VyY2VbXSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCB0aGlzLmN1cnJlbnRUZW1wbGF0ZSgpO1xuICAgIGlmICghdGVtcGxhdGUuUmVzb3VyY2VzKSB7XG4gICAgICB0ZW1wbGF0ZS5SZXNvdXJjZXMgPSB7fTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFkZCBvZiBhZGRpdGlvbnMpIHtcbiAgICAgIHRlbXBsYXRlLlJlc291cmNlc1thZGQubG9naWNhbElkXSA9IGFkZC5yZXNvdXJjZURlZmluaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgaW1wb3J0IGlkZW50aWZpZXJzIGZvciBhbGwgcmVzb3VyY2UgdHlwZXMgdXNlZCBpbiB0aGUgZ2l2ZW5cbiAgICogdGVtcGxhdGUgdGhhdCBkbyBzdXBwb3J0IHRoZSBpbXBvcnQgb3BlcmF0aW9uIChTSU5HTEVUT04pXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbWFwcGluZyBmcm9tIGEgcmVzb3VyY2UgdHlwZSB0byBhIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMgdGhhdCB0b2dldGhlciBpZGVudGlmeSB0aGUgcmVzb3VyY2UgZm9yIGltcG9ydFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZXNvdXJjZUlkZW50aWZpZXJzKCk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVycz4ge1xuICAgIGNvbnN0IHJldDogUmVzb3VyY2VJZGVudGlmaWVycyA9IHt9O1xuICAgIGNvbnN0IHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IGF3YWl0IHRoaXMuY2ZuLnJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyh0aGlzLnN0YWNrKTtcbiAgICBmb3IgKGNvbnN0IHN1bW1hcnkgb2YgcmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzKSB7XG4gICAgICBpZiAoJ1Jlc291cmNlVHlwZScgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlVHlwZSAmJiAnUmVzb3VyY2VJZGVudGlmaWVycycgaW4gc3VtbWFyeSAmJiBzdW1tYXJ5LlJlc291cmNlSWRlbnRpZmllcnMpIHtcbiAgICAgICAgcmV0W3N1bW1hcnkuUmVzb3VyY2VUeXBlXSA9IChzdW1tYXJ5LlJlc291cmNlSWRlbnRpZmllcnMgPz8gW10pPy5tYXAoeCA9PiB4LnNwbGl0KCcsJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzayBmb3IgdGhlIGltcG9ydGFibGUgaWRlbnRpZmllciBmb3IgdGhlIGdpdmVuIHJlc291cmNlXG4gICAqXG4gICAqIFRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGlkZW50aWZpZXIgdW5kZXIgd2hpY2ggYSByZXNvdXJjZSBjYW4gYmUgaW1wb3J0ZWQuIFRoZSBgaW1wb3J0YFxuICAgKiBvcGVyYXRpb24gbmVlZHMgZXhhY3RseSBvbmUgb2YgdGhlbS5cbiAgICpcbiAgICogLSBJZiB3ZSBjYW4gZ2V0IG9uZSBmcm9tIHRoZSB0ZW1wbGF0ZSwgd2Ugd2lsbCB1c2Ugb25lLlxuICAgKiAtIE90aGVyd2lzZSwgd2Ugd2lsbCBhc2sgdGhlIHVzZXIgZm9yIG9uZSBvZiB0aGVtLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBhc2tGb3JSZXNvdXJjZUlkZW50aWZpZXIoXG4gICAgcmVzb3VyY2VJZGVudGlmaWVyczogUmVzb3VyY2VJZGVudGlmaWVycyxcbiAgICBjaGc6IEltcG9ydGFibGVSZXNvdXJjZSxcbiAgKTogUHJvbWlzZTxSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgcmVzb3VyY2VOYW1lID0gdGhpcy5kZXNjcmliZVJlc291cmNlKGNoZy5sb2dpY2FsSWQpO1xuXG4gICAgLy8gU2tpcCByZXNvdXJjZXMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpbXBvcnRpbmdcbiAgICBjb25zdCByZXNvdXJjZVR5cGUgPSBjaGcucmVzb3VyY2VEaWZmLm5ld1Jlc291cmNlVHlwZTtcbiAgICBpZiAocmVzb3VyY2VUeXBlID09PSB1bmRlZmluZWQgfHwgIShyZXNvdXJjZVR5cGUgaW4gcmVzb3VyY2VJZGVudGlmaWVycykpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9XQVJOLm1zZyhgJHtyZXNvdXJjZU5hbWV9OiB1bnN1cHBvcnRlZCByZXNvdXJjZSB0eXBlICR7cmVzb3VyY2VUeXBlfSwgc2tpcHBpbmcgaW1wb3J0LmApKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWRQcm9wU2V0cyA9IHJlc291cmNlSWRlbnRpZmllcnNbcmVzb3VyY2VUeXBlXTtcblxuICAgIC8vIFJldGFpbiBvbmx5IGxpdGVyYWwgc3RyaW5nczogc3RyaXAgcG90ZW50aWFsIENGTiBpbnRyaW5zaWNzXG4gICAgY29uc3QgcmVzb3VyY2VQcm9wcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhjaGcucmVzb3VyY2VEZWZpbml0aW9uLlByb3BlcnRpZXMgPz8ge30pXG4gICAgICAuZmlsdGVyKChbXywgdl0pID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJykpIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgICAvLyBGaW5kIHByb3BlcnR5IHNldHMgdGhhdCBhcmUgZnVsbHkgc2F0aXNmaWVkIGluIHRoZSB0ZW1wbGF0ZSwgYXNrIHRoZSB1c2VyIHRvIGNvbmZpcm0gdGhlbVxuICAgIGNvbnN0IHNhdGlzZmllZFByb3BTZXRzID0gaWRQcm9wU2V0cy5maWx0ZXIocHMgPT4gcHMuZXZlcnkocCA9PiByZXNvdXJjZVByb3BzW3BdKSk7XG4gICAgZm9yIChjb25zdCBzYXRpc2ZpZWRQcm9wU2V0IG9mIHNhdGlzZmllZFByb3BTZXRzKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGVQcm9wcyA9IE9iamVjdC5mcm9tRW50cmllcyhzYXRpc2ZpZWRQcm9wU2V0Lm1hcChwID0+IFtwLCByZXNvdXJjZVByb3BzW3BdXSkpO1xuICAgICAgY29uc3QgZGlzcGxheUNhbmRpZGF0ZVByb3BzID0gZm10ZGljdChjYW5kaWRhdGVQcm9wcyk7XG5cbiAgICAgIGlmIChhd2FpdCBwcm9tcHRseS5jb25maXJtKFxuICAgICAgICBgJHtjaGFsay5ibHVlKHJlc291cmNlTmFtZSl9ICgke3Jlc291cmNlVHlwZX0pOiBpbXBvcnQgd2l0aCAke2NoYWxrLnllbGxvdyhkaXNwbGF5Q2FuZGlkYXRlUHJvcHMpfSAoeWVzL25vKSBbZGVmYXVsdDogeWVzXT8gYCxcbiAgICAgICAgeyBkZWZhdWx0OiAneWVzJyB9LFxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlUHJvcHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ290IGhlcmUgYW5kIHRoZSB1c2VyIHJlamVjdGVkIGFueSBhdmFpbGFibGUgaWRlbnRpZmllcnMsIHRoZW4gYXBwYXJlbnRseSB0aGV5IGRvbid0IHdhbnQgdGhlIHJlc291cmNlIGF0IGFsbFxuICAgIGlmIChzYXRpc2ZpZWRQcm9wU2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfSU5GTy5tc2coY2hhbGsuZ3JleShgU2tpcHBpbmcgaW1wb3J0IG9mICR7cmVzb3VyY2VOYW1lfWApKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbm5vdCBhdXRvLWltcG9ydCB0aGlzLCBhc2sgdGhlIHVzZXIgZm9yIG9uZSBvZiB0aGUgcHJvcHNcbiAgICAvLyBUaGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlc2UgY2FzZXMgaXMgd2hhdCB3ZSBwcmludDogZm9yIG11bHRpcGxlIHByb3BlcnRpZXMsIHdlIHByaW50IGEgcHJlYW1ibGVcbiAgICBjb25zdCBwcmVmaXggPSBgJHtjaGFsay5ibHVlKHJlc291cmNlTmFtZSl9ICgke3Jlc291cmNlVHlwZX0pYDtcbiAgICBsZXQgcHJlYW1ibGU7XG4gICAgbGV0IHByb21wdFBhdHRlcm47XG4gICAgaWYgKGlkUHJvcFNldHMubGVuZ3RoID4gMSkge1xuICAgICAgcHJlYW1ibGUgPSBgJHtwcmVmaXh9OiBlbnRlciBvbmUgb2YgJHtpZFByb3BTZXRzLm1hcCh4ID0+IGNoYWxrLmJsdWUoeC5qb2luKCcrJykpKS5qb2luKCcsICcpfSB0byBpbXBvcnQgKGFsbCBlbXB0eSB0byBza2lwKWA7XG4gICAgICBwcm9tcHRQYXR0ZXJuID0gYCR7cHJlZml4fTogZW50ZXIgJWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21wdFBhdHRlcm4gPSBgJHtwcmVmaXh9OiBlbnRlciAlYDtcbiAgICB9XG5cbiAgICAvLyBEbyB0aGUgaW5wdXQgbG9vcCBoZXJlXG4gICAgaWYgKHByZWFtYmxlKSB7XG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfSU5GTy5tc2cocHJlYW1ibGUpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpZFByb3BzIG9mIGlkUHJvcFNldHMpIHtcbiAgICAgIGNvbnN0IGlucHV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGlkUHJvcCBvZiBpZFByb3BzKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2YWx1ZSBmcm9tIHRoZSB0ZW1wbGF0ZSwgdXNlIGl0IGFzIGRlZmF1bHQuIFRoaXMgd2lsbCBvbmx5IGJlIGEgcGFydGlhbFxuICAgICAgICAvLyBpZGVudGlmaWVyIGlmIHByZXNlbnQsIG90aGVyd2lzZSB3ZSB3b3VsZCBoYXZlIGRvbmUgdGhlIGltcG9ydCBhbHJlYWR5IGFib3ZlLlxuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSByZXNvdXJjZVByb3BzW2lkUHJvcF0gPz8gJyc7XG5cbiAgICAgICAgY29uc3QgcHJvbXB0ID0gW1xuICAgICAgICAgIHByb21wdFBhdHRlcm4ucmVwbGFjZSgvJS9nLCBjaGFsay5ibHVlKGlkUHJvcCkpLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgPyBgWyR7ZGVmYXVsdFZhbHVlfV1gXG4gICAgICAgICAgICA6ICcoZW1wdHkgdG8gc2tpcCknLFxuICAgICAgICBdLmpvaW4oJyAnKSArICc6JztcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwcm9tcHRseS5wcm9tcHQocHJvbXB0LFxuICAgICAgICAgIHsgZGVmYXVsdDogZGVmYXVsdFZhbHVlLCB0cmltOiB0cnVlIH0sXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRbaWRQcm9wXSA9IHJlc3BvbnNlO1xuICAgICAgICAvLyBBbHNvIHN0aWNrIHRoaXMgcHJvcGVydHkgaW50byAncmVzb3VyY2VQcm9wcycsIHNvIHRoYXQgaXQgbWF5IGJlIHJldXNlZCBieSBhIHN1YnNlcXVlbnQgcXVlc3Rpb25cbiAgICAgICAgLy8gKGZvciBhIGRpZmZlcmVudCBjb21wb3VuZCBpZGVudGlmaWVyIHRoYXQgaW52b2x2ZXMgdGhlIHNhbWUgcHJvcGVydHkpLiBKdXN0IGEgc21hbGwgVVggZW5oYW5jZW1lbnQuXG4gICAgICAgIHJlc291cmNlUHJvcHNbaWRQcm9wXSA9IHJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgdXNlciBnYXZlIGlucHV0cyBmb3IgYWxsIHZhbHVlcywgd2UgYXJlIGNvbXBsZXRlXG4gICAgICBpZiAoT2JqZWN0LmtleXMoaW5wdXQpLmxlbmd0aCA9PT0gaWRQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9JTkZPLm1zZyhjaGFsay5ncmV5KGBTa2lwcGluZyBpbXBvcnQgb2YgJHtyZXNvdXJjZU5hbWV9YCkpKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGludGVybmFsIFwicmVzb3VyY2UgbWFwcGluZ1wiIHN0cnVjdHVyZSB0byBDbG91ZEZvcm1hdGlvbiBhY2NlcHRlZCBcIlJlc291cmNlc1RvSW1wb3J0XCIgc3RydWN0dXJlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIG1ha2VSZXNvdXJjZXNUb0ltcG9ydChyZXNvdXJjZU1hcDogSW1wb3J0TWFwKTogUHJvbWlzZTxSZXNvdXJjZXNUb0ltcG9ydD4ge1xuICAgIHJldHVybiByZXNvdXJjZU1hcC5pbXBvcnRSZXNvdXJjZXMubWFwKHJlcyA9PiAoe1xuICAgICAgTG9naWNhbFJlc291cmNlSWQ6IHJlcy5sb2dpY2FsSWQsXG4gICAgICBSZXNvdXJjZVR5cGU6IHJlcy5yZXNvdXJjZURpZmYubmV3UmVzb3VyY2VUeXBlISxcbiAgICAgIFJlc291cmNlSWRlbnRpZmllcjogcmVzb3VyY2VNYXAucmVzb3VyY2VNYXBbcmVzLmxvZ2ljYWxJZF0sXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgQ2xvdWRGb3JtYXRpb24gbG9naWNhbCByZXNvdXJjZSBJRCB0byBDREsgY29uc3RydWN0IHRyZWUgcGF0aFxuICAgKlxuICAgKiBAcGFyYW0gbG9naWNhbElkIENsb3VkRm9ybWF0aW9uIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlICh0aGUga2V5IGluIHRoZSB0ZW1wbGF0ZSdzIFJlc291cmNlcyBzZWN0aW9uKVxuICAgKiBAcmV0dXJucyBGb3J3YXJkLXNsYXNoIHNlcGFyYXRlZCBwYXRoIG9mIHRoZSByZXNvdXJjZSBpbiBDREsgY29uc3RydWN0IHRyZWUsIGUuZy4gTXlTdGFjay9NeUJ1Y2tldC9SZXNvdXJjZVxuICAgKi9cbiAgcHJpdmF0ZSBkZXNjcmliZVJlc291cmNlKGxvZ2ljYWxJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay50ZW1wbGF0ZT8uUmVzb3VyY2VzPy5bbG9naWNhbElkXT8uTWV0YWRhdGE/LlsnYXdzOmNkazpwYXRoJ10gPz8gbG9naWNhbElkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgQ0RLTWV0YWRhdGEgYW5kIE91dHB1dHMgaW4gdGhlIHRlbXBsYXRlIHNvIHRoYXQgb25seSByZXNvdXJjZXMgZm9yIGltcG9ydGluZyBhcmUgbGVmdC5cbiAgICogQHJldHVybnMgdGVtcGxhdGUgd2l0aCBpbXBvcnQgcmVzb3VyY2VzIG9ubHlcbiAgICovXG4gIHByaXZhdGUgcmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzKCkge1xuICAgIHJldHVybiByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXModGhpcy5zdGFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIHJlc291cmNlIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGlzIGltcG9ydGFibGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRhYmxlUmVzb3VyY2Uge1xuICAvKipcbiAgICogVGhlIGxvZ2ljYWwgSUQgb2YgdGhlIHJlc291cmNlXG4gICAqL1xuICByZWFkb25seSBsb2dpY2FsSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHJlc291cmNlIGRlZmluaXRpb24gaW4gdGhlIG5ldyB0ZW1wbGF0ZVxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VEZWZpbml0aW9uOiBhbnk7XG5cbiAgLyoqXG4gICAqIFRoZSBkaWZmIGFzIHJlcG9ydGVkIGJ5IGBjbG91ZGZvcm1hdGlvbi1kaWZmYC5cbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlRGlmZjogUmVzb3VyY2VEaWZmZXJlbmNlO1xufVxuXG4vKipcbiAqIFRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gZXhlY3V0ZSBhbiBpbXBvcnQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1wb3J0TWFwIHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgbG9naWNhbCBJRHMgdG8gcGh5c2ljYWwgbmFtZXNcbiAgICovXG4gIHJlYWRvbmx5IHJlc291cmNlTWFwOiBSZXNvdXJjZU1hcDtcblxuICAvKipcbiAgICogVGhlIHNlbGVjdGlvbiBvZiByZXNvdXJjZXMgd2UgYXJlIGFjdHVhbGx5IGltcG9ydGluZ1xuICAgKlxuICAgKiBGb3IgZWFjaCBvZiB0aGUgcmVzb3VyY2VzIGluIHRoaXMgbGlzdCwgdGhlcmUgaXMgYSBjb3JyZXNwb25kaW5nIGVudHJ5IGluXG4gICAqIHRoZSBgcmVzb3VyY2VNYXBgIG1hcC5cbiAgICovXG4gIHJlYWRvbmx5IGltcG9ydFJlc291cmNlczogSW1wb3J0YWJsZVJlc291cmNlW107XG59XG5cbmZ1bmN0aW9uIGZtdGRpY3Q8QT4oeHM6IFJlY29yZDxzdHJpbmcsIEE+KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh4cykubWFwKChbaywgdl0pID0+IGAke2t9PSR7dn1gKS5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIEFkZCBhIGRlZmF1bHQgYERlbGV0aW9uUG9saWN5YCBwb2xpY3kuXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBzZXQgdG8gJ1JldGFpbicsIHRvIGxvd2VyIHJpc2sgb2YgdW5pbnRlbnRpb25hbGx5XG4gKiBkZWxldGluZyBzdGF0ZWZ1bCByZXNvdXJjZXMgaW4gdGhlIHByb2Nlc3Mgb2YgaW1wb3J0aW5nIHRvIENESy5cbiAqL1xuZnVuY3Rpb24gYWRkRGVmYXVsdERlbGV0aW9uUG9saWN5KHJlc291cmNlOiBhbnkpOiBhbnkge1xuICBpZiAocmVzb3VyY2UuRGVsZXRpb25Qb2xpY3kpIHtcbiAgICByZXR1cm4gcmVzb3VyY2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnJlc291cmNlLFxuICAgIERlbGV0aW9uUG9saWN5OiAnUmV0YWluJyxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXNSZXN1bHQge1xuICByZWFkb25seSBhZGRpdGlvbnM6IEltcG9ydGFibGVSZXNvdXJjZVtdO1xuICByZWFkb25seSBoYXNOb25BZGRpdGlvbnM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMoc3RhY2s6Y3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSB7XG4gIGNvbnN0IHRlbXBsYXRlID0gc3RhY2sudGVtcGxhdGU7XG4gIGRlbGV0ZSB0ZW1wbGF0ZS5SZXNvdXJjZXMuQ0RLTWV0YWRhdGE7XG4gIGRlbGV0ZSB0ZW1wbGF0ZS5PdXRwdXRzO1xuICByZXR1cm4gdGVtcGxhdGU7XG59XG4iXX0=